<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_06) on Fri Feb 11 11:55:53 GMT 2005 -->
<TITLE>
ExpressionParser
</TITLE>

<META NAME="keywords" CONTENT="net.sf.saxon.expr.ExpressionParser class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ExpressionParser";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/sf/saxon/expr/ExpressionLocation.html" title="class in net.sf.saxon.expr"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../net/sf/saxon/expr/ExpressionParser.ForClause.html" title="class in net.sf.saxon.expr"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ExpressionParser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.sf.saxon.expr</FONT>
<BR>
Class ExpressionParser</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by"><B>net.sf.saxon.expr.ExpressionParser</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../../net/sf/saxon/query/QueryParser.html" title="class in net.sf.saxon.query">QueryParser</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>ExpressionParser</B><DT>extends java.lang.Object</DL>

<P>
Parser for XPath expressions and XSLT patterns.

 This code was originally inspired by James Clark's xt but has been totally rewritten (several times)
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.ForClause.html" title="class in net.sf.saxon.expr">ExpressionParser.ForClause</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#env">env</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Stack</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#rangeVariables">rangeVariables</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#scanOnly">scanOnly</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Tokenizer.html" title="class in net.sf.saxon.expr">Tokenizer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#t">t</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#ExpressionParser()">ExpressionParser</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#currentTokenDisplay()">currentTokenDisplay</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Display the current token in an error message</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#declareRangeVariable(net.sf.saxon.expr.VariableDeclaration)">declareRangeVariable</A></B>(<A HREF="../../../../net/sf/saxon/expr/VariableDeclaration.html" title="interface in net.sf.saxon.expr">VariableDeclaration</A>&nbsp;declaration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Declare a range variable (record its existence within the parser).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#expect(int)">expect</A></B>(int&nbsp;token)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expect a given token, fail if the current token is different</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#getLanguage()">getLanguage</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the current language (XPath or XQuery)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Stack</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#getRangeVariableStack()">getRangeVariableStack</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the range variable stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/expr/Tokenizer.html" title="class in net.sf.saxon.expr">Tokenizer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#getTokenizer()">getTokenizer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#grumble(java.lang.String)">grumble</A></B>(java.lang.String&nbsp;message)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Report a syntax error (a static error with error code XP0003)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#grumble(java.lang.String, java.lang.String)">grumble</A></B>(java.lang.String&nbsp;message,
        java.lang.String&nbsp;errorCode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Report a static error</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#isKeyword(java.lang.String)">isKeyword</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test whether the current token is a given keyword.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/pattern/LocalNameTest.html" title="class in net.sf.saxon.pattern">LocalNameTest</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeLocalNameTest(short, java.lang.String)">makeLocalNameTest</A></B>(short&nbsp;nodeType,
                  java.lang.String&nbsp;localName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a LocalNameTest (*:name)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeNameCode(java.lang.String, boolean)">makeNameCode</A></B>(java.lang.String&nbsp;qname,
             boolean&nbsp;useDefault)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a NameCode, using this Element as the context for namespace resolution</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/pattern/NamespaceTest.html" title="class in net.sf.saxon.pattern">NamespaceTest</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeNamespaceTest(short, java.lang.String)">makeNamespaceTest</A></B>(short&nbsp;nodeType,
                  java.lang.String&nbsp;prefix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a NamespaceTest (name:*)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/pattern/NameTest.html" title="class in net.sf.saxon.pattern">NameTest</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeNameTest(short, java.lang.String, boolean)">makeNameTest</A></B>(short&nbsp;nodeType,
             java.lang.String&nbsp;qname,
             boolean&nbsp;useDefault)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a NameTest, using the static context for namespace resolution</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/value/StringValue.html" title="class in net.sf.saxon.value">StringValue</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeStringLiteral(java.lang.String)">makeStringLiteral</A></B>(java.lang.String&nbsp;currentTokenValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method to make a string literal from a token identified as a string
 literal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#makeTracer(int, net.sf.saxon.expr.Expression, int, int)">makeTracer</A></B>(int&nbsp;startOffset,
           <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A>&nbsp;exp,
           int&nbsp;construct,
           int&nbsp;objectNameCode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If tracing, wrap an instruction in a trace instruction</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#nextToken()">nextToken</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read the next token, catching any exception thrown by the tokenizer</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parse(java.lang.String, int, int, int, net.sf.saxon.expr.StaticContext)">parse</A></B>(java.lang.String&nbsp;expression,
      int&nbsp;start,
      int&nbsp;terminator,
      int&nbsp;lineNumber,
      <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a string representing an expression</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseConstructor()">parseConstructor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a node constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseExpression()">parseExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a top-level Expression:
 ExprSingle ( ',' ExprSingle )*</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseExprSingle()">parseExprSingle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse an ExprSingle</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseExtensionExpression()">parseExtensionExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse an Extension Expression
 This construct is XQuery-only, so the XPath version of this
 method throws an error unconditionally</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseForExpression()">parseForExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a FOR expression:
 for $x in expr (',' $y in expr)* 'return' expr</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseMappingExpression()">parseMappingExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a mapping expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/pattern/NodeTest.html" title="class in net.sf.saxon.pattern">NodeTest</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseNodeTest(short)">parseNodeTest</A></B>(short&nbsp;nodeType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a NodeTest.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/pattern/Pattern.html" title="class in net.sf.saxon.pattern">Pattern</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parsePattern(java.lang.String, net.sf.saxon.expr.StaticContext)">parsePattern</A></B>(java.lang.String&nbsp;pattern,
             <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a string representing an XSLT pattern</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseRelativePath()">parseRelativePath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a relative path (a sequence of steps).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/value/SequenceType.html" title="class in net.sf.saxon.value">SequenceType</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseSequenceType()">parseSequenceType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse the sequence type production.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../net/sf/saxon/value/SequenceType.html" title="class in net.sf.saxon.value">SequenceType</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseSequenceType(java.lang.String, net.sf.saxon.expr.StaticContext)">parseSequenceType</A></B>(java.lang.String&nbsp;input,
                  <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a string representing a sequence type</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseStepExpression()">parseStepExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a step (including an optional sequence of predicates)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseTypeswitchExpression()">parseTypeswitchExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a Typeswitch Expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#parseValidateExpression()">parseValidateExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parse a Validate Expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#setLocation(net.sf.saxon.expr.Expression)">setLocation</A></B>(<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A>&nbsp;exp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set location information on an expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#setLocation(net.sf.saxon.expr.Expression, int)">setLocation</A></B>(<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A>&nbsp;exp,
            int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set location information on an expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#setRangeVariableStack(java.util.Stack)">setRangeVariableStack</A></B>(java.util.Stack&nbsp;stack)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the range variable stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#setScanOnly(boolean)">setScanOnly</A></B>(boolean&nbsp;scanOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#undeclareRangeVariable()">undeclareRangeVariable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note when the most recently declared range variable has gone out of scope</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../net/sf/saxon/expr/ExpressionParser.html#warning(java.lang.String)">warning</A></B>(java.lang.String&nbsp;message)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output a warning message</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="t"><!-- --></A><H3>
t</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Tokenizer.html" title="class in net.sf.saxon.expr">Tokenizer</A> <B>t</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="env"><!-- --></A><H3>
env</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A> <B>env</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="rangeVariables"><!-- --></A><H3>
rangeVariables</H3>
<PRE>
protected java.util.Stack <B>rangeVariables</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="scanOnly"><!-- --></A><H3>
scanOnly</H3>
<PRE>
protected boolean <B>scanOnly</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ExpressionParser()"><!-- --></A><H3>
ExpressionParser</H3>
<PRE>
public <B>ExpressionParser</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="getTokenizer()"><!-- --></A><H3>
getTokenizer</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/expr/Tokenizer.html" title="class in net.sf.saxon.expr">Tokenizer</A> <B>getTokenizer</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nextToken()"><!-- --></A><H3>
nextToken</H3>
<PRE>
protected void <B>nextToken</B>()
                  throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Read the next token, catching any exception thrown by the tokenizer
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="expect(int)"><!-- --></A><H3>
expect</H3>
<PRE>
protected void <B>expect</B>(int&nbsp;token)
               throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Expect a given token, fail if the current token is different
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>token</CODE> - the expected token
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if the current token is not the expected
     token</DL>
</DD>
</DL>
<HR>

<A NAME="grumble(java.lang.String)"><!-- --></A><H3>
grumble</H3>
<PRE>
protected void <B>grumble</B>(java.lang.String&nbsp;message)
                throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Report a syntax error (a static error with error code XP0003)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>message</CODE> - the error message
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - always thrown: an exception containing the
     supplied message</DL>
</DD>
</DL>
<HR>

<A NAME="grumble(java.lang.String, java.lang.String)"><!-- --></A><H3>
grumble</H3>
<PRE>
protected void <B>grumble</B>(java.lang.String&nbsp;message,
                       java.lang.String&nbsp;errorCode)
                throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Report a static error
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>message</CODE> - the error message<DD><CODE>errorCode</CODE> - the error code
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - always thrown: an exception containing the
     supplied message</DL>
</DD>
</DL>
<HR>

<A NAME="warning(java.lang.String)"><!-- --></A><H3>
warning</H3>
<PRE>
protected void <B>warning</B>(java.lang.String&nbsp;message)
                throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Output a warning message
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getLanguage()"><!-- --></A><H3>
getLanguage</H3>
<PRE>
protected java.lang.String <B>getLanguage</B>()</PRE>
<DL>
<DD>Get the current language (XPath or XQuery)
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="currentTokenDisplay()"><!-- --></A><H3>
currentTokenDisplay</H3>
<PRE>
protected java.lang.String <B>currentTokenDisplay</B>()</PRE>
<DL>
<DD>Display the current token in an error message
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the display representation of the token</DL>
</DD>
</DL>
<HR>

<A NAME="parse(java.lang.String, int, int, int, net.sf.saxon.expr.StaticContext)"><!-- --></A><H3>
parse</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A> <B>parse</B>(java.lang.String&nbsp;expression,
                        int&nbsp;start,
                        int&nbsp;terminator,
                        int&nbsp;lineNumber,
                        <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env)
                 throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse a string representing an expression
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>expression</CODE> - the expression expressed as a String<DD><CODE>start</CODE> - offset within the string where parsing is to start<DD><CODE>terminator</CODE> - character to treat as terminating the expression<DD><CODE>lineNumber</CODE> - location of the start of the expression, for diagnostics<DD><CODE>env</CODE> - the static context for the expression
<DT><B>Returns:</B><DD>an Expression object representing the result of parsing
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if the expression contains a syntax error</DL>
</DD>
</DL>
<HR>

<A NAME="parsePattern(java.lang.String, net.sf.saxon.expr.StaticContext)"><!-- --></A><H3>
parsePattern</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/pattern/Pattern.html" title="class in net.sf.saxon.pattern">Pattern</A> <B>parsePattern</B>(java.lang.String&nbsp;pattern,
                            <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env)
                     throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse a string representing an XSLT pattern
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - the pattern expressed as a String<DD><CODE>env</CODE> - the static context for the pattern
<DT><B>Returns:</B><DD>a Pattern object representing the result of parsing
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if the pattern contains a syntax error</DL>
</DD>
</DL>
<HR>

<A NAME="parseSequenceType(java.lang.String, net.sf.saxon.expr.StaticContext)"><!-- --></A><H3>
parseSequenceType</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/value/SequenceType.html" title="class in net.sf.saxon.value">SequenceType</A> <B>parseSequenceType</B>(java.lang.String&nbsp;input,
                                      <A HREF="../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env)
                               throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse a string representing a sequence type
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>input</CODE> - the string, which should conform to the XPath SequenceType
      production<DD><CODE>env</CODE> - the static context
<DT><B>Returns:</B><DD>a SequenceType object representing the type
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseExpression()"><!-- --></A><H3>
parseExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A> <B>parseExpression</B>()
                              throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse a top-level Expression:
 ExprSingle ( ',' ExprSingle )*
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the Expression object that results from parsing
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if the expression contains a syntax error</DL>
</DD>
</DL>
<HR>

<A NAME="parseExprSingle()"><!-- --></A><H3>
parseExprSingle</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A> <B>parseExprSingle</B>()
                              throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse an ExprSingle
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseTypeswitchExpression()"><!-- --></A><H3>
parseTypeswitchExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A> <B>parseTypeswitchExpression</B>()
                                        throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse a Typeswitch Expression.
 This construct is XQuery-only, so the XPath version of this
 method throws an error unconditionally
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseValidateExpression()"><!-- --></A><H3>
parseValidateExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A> <B>parseValidateExpression</B>()
                                      throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse a Validate Expression.
 This construct is XQuery-only, so the XPath version of this
 method throws an error unconditionally
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseExtensionExpression()"><!-- --></A><H3>
parseExtensionExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A> <B>parseExtensionExpression</B>()
                                       throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse an Extension Expression
 This construct is XQuery-only, so the XPath version of this
 method throws an error unconditionally
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseForExpression()"><!-- --></A><H3>
parseForExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A> <B>parseForExpression</B>()
                                 throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse a FOR expression:
 for $x in expr (',' $y in expr)* 'return' expr
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseMappingExpression()"><!-- --></A><H3>
parseMappingExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A> <B>parseMappingExpression</B>()
                                     throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse a mapping expression. This is a common routine that handles
 XPath for expressions and quantified expressions.

 <p>Syntax: <br/>
 (for|some|every) $x in expr (',' $y in expr)* (return|satisfies) expr
 </p>

 <p>On entry, the current token indicates whether a for, some, or every
 expression is expected.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseSequenceType()"><!-- --></A><H3>
parseSequenceType</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/value/SequenceType.html" title="class in net.sf.saxon.value">SequenceType</A> <B>parseSequenceType</B>()
                                  throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse the sequence type production.
 Provisionally, we use the syntax (QName | node-kind "()") ( "*" | "+" | "?" )?
 We also allow "element of type QName" and "attribute of type QName"
 The QName must be the name of a built-in schema-defined data type.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseRelativePath()"><!-- --></A><H3>
parseRelativePath</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A> <B>parseRelativePath</B>()
                                throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse a relative path (a sequence of steps). Called when the current token immediately
 follows a separator (/ or //), or an implicit separator (XYZ is equivalent to ./XYZ)
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="parseStepExpression()"><!-- --></A><H3>
parseStepExpression</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A> <B>parseStepExpression</B>()
                                  throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse a step (including an optional sequence of predicates)
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the resulting subexpression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="makeStringLiteral(java.lang.String)"><!-- --></A><H3>
makeStringLiteral</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/value/StringValue.html" title="class in net.sf.saxon.value">StringValue</A> <B>makeStringLiteral</B>(java.lang.String&nbsp;currentTokenValue)
                                 throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Method to make a string literal from a token identified as a string
 literal. This is trivial in XPath, but in XQuery the method is overridden
 to identify pseudo-XML character and entity references. Note that the job of handling
 doubled string delimiters is done by the tokenizer.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>currentTokenValue</CODE> - 
<DT><B>Returns:</B><DD>The string value of the string literal
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseConstructor()"><!-- --></A><H3>
parseConstructor</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A> <B>parseConstructor</B>()
                               throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse a node constructor. This is allowed only in XQuery, so the method throws
 an error for XPath.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parseNodeTest(short)"><!-- --></A><H3>
parseNodeTest</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/pattern/NodeTest.html" title="class in net.sf.saxon.pattern">NodeTest</A> <B>parseNodeTest</B>(short&nbsp;nodeType)
                          throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Parse a NodeTest.
 One of QName, prefix:*, *:suffix, *, text(), node(), comment(), or
 processing-instruction(literal?), or element(~,~), attribute(~,~), etc.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeType</CODE> - the node type being sought if one is specified
<DT><B>Returns:</B><DD>the resulting NodeTest object
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="declareRangeVariable(net.sf.saxon.expr.VariableDeclaration)"><!-- --></A><H3>
declareRangeVariable</H3>
<PRE>
protected void <B>declareRangeVariable</B>(<A HREF="../../../../net/sf/saxon/expr/VariableDeclaration.html" title="interface in net.sf.saxon.expr">VariableDeclaration</A>&nbsp;declaration)
                             throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Declare a range variable (record its existence within the parser).
 A range variable is a variable declared within an expression, as distinct
 from a variable declared in the context.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>declaration</CODE> - the VariableDeclaration to be added to the stack
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if any error is encountered</DL>
</DD>
</DL>
<HR>

<A NAME="undeclareRangeVariable()"><!-- --></A><H3>
undeclareRangeVariable</H3>
<PRE>
protected void <B>undeclareRangeVariable</B>()</PRE>
<DL>
<DD>Note when the most recently declared range variable has gone out of scope
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRangeVariableStack()"><!-- --></A><H3>
getRangeVariableStack</H3>
<PRE>
public java.util.Stack <B>getRangeVariableStack</B>()</PRE>
<DL>
<DD>Get the range variable stack. Used when parsing a nested subexpression
 inside an attribute constructor
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRangeVariableStack(java.util.Stack)"><!-- --></A><H3>
setRangeVariableStack</H3>
<PRE>
public void <B>setRangeVariableStack</B>(java.util.Stack&nbsp;stack)</PRE>
<DL>
<DD>Set the range variable stack. Used when parsing a nested subexpression
 inside an attribute constructor.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeNameCode(java.lang.String, boolean)"><!-- --></A><H3>
makeNameCode</H3>
<PRE>
public final int <B>makeNameCode</B>(java.lang.String&nbsp;qname,
                              boolean&nbsp;useDefault)
                       throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Make a NameCode, using this Element as the context for namespace resolution
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>qname</CODE> - The name as written, in the form "[prefix:]localname"<DD><CODE>useDefault</CODE> - Defines the action when there is no prefix. If
      true, use the default namespace URI for element names. If false,
     use no namespace URI (as for attribute names).
<DT><B>Returns:</B><DD>the namecode, which can be used to identify this name in the
     name pool
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if the name is invalid, or the prefix
     undeclared</DL>
</DD>
</DL>
<HR>

<A NAME="makeNameTest(short, java.lang.String, boolean)"><!-- --></A><H3>
makeNameTest</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/pattern/NameTest.html" title="class in net.sf.saxon.pattern">NameTest</A> <B>makeNameTest</B>(short&nbsp;nodeType,
                             java.lang.String&nbsp;qname,
                             boolean&nbsp;useDefault)
                      throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Make a NameTest, using the static context for namespace resolution
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeType</CODE> - the type of node required (identified by a constant in
     class Type)<DD><CODE>qname</CODE> - the lexical QName of the required node<DD><CODE>useDefault</CODE> - true if the default namespace should be used when
     the QName is unprefixed
<DT><B>Returns:</B><DD>a NameTest, representing a pattern that tests for a node of a
     given node kind and a given name
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if the QName is invalid</DL>
</DD>
</DL>
<HR>

<A NAME="makeNamespaceTest(short, java.lang.String)"><!-- --></A><H3>
makeNamespaceTest</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/pattern/NamespaceTest.html" title="class in net.sf.saxon.pattern">NamespaceTest</A> <B>makeNamespaceTest</B>(short&nbsp;nodeType,
                                       java.lang.String&nbsp;prefix)
                                throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Make a NamespaceTest (name:*)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeType</CODE> - integer code identifying the type of node required<DD><CODE>prefix</CODE> - the namespace prefix
<DT><B>Returns:</B><DD>the NamespaceTest, a pattern that matches all nodes in this
     namespace
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if the namespace prefix is not declared</DL>
</DD>
</DL>
<HR>

<A NAME="makeLocalNameTest(short, java.lang.String)"><!-- --></A><H3>
makeLocalNameTest</H3>
<PRE>
public <A HREF="../../../../net/sf/saxon/pattern/LocalNameTest.html" title="class in net.sf.saxon.pattern">LocalNameTest</A> <B>makeLocalNameTest</B>(short&nbsp;nodeType,
                                       java.lang.String&nbsp;localName)
                                throws <A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></PRE>
<DL>
<DD>Make a LocalNameTest (*:name)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nodeType</CODE> - the kind of node to be matched<DD><CODE>localName</CODE> - the requred local name
<DT><B>Returns:</B><DD>a LocalNameTest, a pattern which matches all nodes of a given
     local name, regardless of namespace
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../net/sf/saxon/trans/StaticError.html" title="class in net.sf.saxon.trans">StaticError</A></CODE> - if the local name is invalid</DL>
</DD>
</DL>
<HR>

<A NAME="setLocation(net.sf.saxon.expr.Expression)"><!-- --></A><H3>
setLocation</H3>
<PRE>
protected void <B>setLocation</B>(<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A>&nbsp;exp)</PRE>
<DL>
<DD>Set location information on an expression. At present this consists of a simple
 line number. Needed mainly for XQuery.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setLocation(net.sf.saxon.expr.Expression, int)"><!-- --></A><H3>
setLocation</H3>
<PRE>
protected void <B>setLocation</B>(<A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A>&nbsp;exp,
                           int&nbsp;offset)</PRE>
<DL>
<DD>Set location information on an expression. At present only the line number
 is retained. Needed mainly for XQuery. This version of the method supplies an
 explicit offset (character position within the expression or query), which the tokenizer
 can convert to a line number and column number.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeTracer(int, net.sf.saxon.expr.Expression, int, int)"><!-- --></A><H3>
makeTracer</H3>
<PRE>
protected <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A> <B>makeTracer</B>(int&nbsp;startOffset,
                                <A HREF="../../../../net/sf/saxon/expr/Expression.html" title="interface in net.sf.saxon.expr">Expression</A>&nbsp;exp,
                                int&nbsp;construct,
                                int&nbsp;objectNameCode)</PRE>
<DL>
<DD>If tracing, wrap an instruction in a trace instruction
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isKeyword(java.lang.String)"><!-- --></A><H3>
isKeyword</H3>
<PRE>
protected boolean <B>isKeyword</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD>Test whether the current token is a given keyword.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The string to be compared with the current token
<DT><B>Returns:</B><DD>true if they are the same</DL>
</DD>
</DL>
<HR>

<A NAME="setScanOnly(boolean)"><!-- --></A><H3>
setScanOnly</H3>
<PRE>
public void <B>setScanOnly</B>(boolean&nbsp;scanOnly)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../net/sf/saxon/expr/ExpressionLocation.html" title="class in net.sf.saxon.expr"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../net/sf/saxon/expr/ExpressionParser.ForClause.html" title="class in net.sf.saxon.expr"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ExpressionParser.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
